#!/usr/bin/env bash

export VAULT_ADDR="https://vault.homelab.dmann.xyz:8200"
ip addr add 2403:5806:97ec:2::76:6175:6C74/24 dev eth0

apt update && apt install gpg snapd
wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg >/dev/null
gpg --no-default-keyring --keyring /usr/share/keyrings/hashicorp-archive-keyring.gpg --fingerprint
echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
sudo apt update && sudo apt install vault jq


snap install core
sudo snap refresh core
snap install --classic certbot
snap install --classic terraform

ln -s /snap/bin/certbot /usr/bin/certbot 

cat << 'EOF' > /etc/vault.d/vault.hcl
ui = true
storage "file" {
  path = "/opt/vault/data"
}
listener "tcp" {
  address       = "[::]:8200"
  tls_cert_file = "/opt/vault/tls/tls.crt"
  tls_key_file  = "/opt/vault/tls/tls.key"
}
api_addr = "https://vault.homelab.dmann.xyz:8200"

EOF
cat << 'EOF' > /opt/vault/tls-renew-hook.sh
#!/usr/bin/env bash

cp ${RENEWED_LINEAGE}/fullchain.pem /opt/vault/tls/tls.crt && chown vault:vault /opt/vault/tls/tls.crt
cp ${RENEWED_LINEAGE}/privkey.pem /opt/vault/tls/tls.key && chown vault:vault /opt/vault/tls/tls.key
systemctl reload vault || true
EOF
chmod +x /opt/vault/tls-renew-hook.sh

certbot certonly --deploy-hook /opt/vault/tls-renew-hook.sh --standalone -d vault.homelab.dmann.xyz -m ninja@codingninja.com.au --agree-tos -n

systemctl enable --now vault
systemctl reload vault

if [ ! -s "/opt/vault/init.json" ]; then
    vault operator init -format json > /opt/vault/init.json
fi


mkdir -p /opt/vault/terraform /var/log/vault/ && chown -R vault:vault /var/log/vault/
cd /opt/vault/terraform
rm *.tf

cat << EOF > main.tf
provider "vault" {}

locals {
  default_3y_in_sec   = 94608000
  default_1y_in_sec   = 31536000
  default_1hr_in_sec = 3600
  nodes = {
    poweredge01: {
      ips = ["10.0.1.110"]
    },
    poweredge02: {
      ips = ["10.0.1.113"]
    }
  }
}

EOF


cat << EOF > audit.tf
resource "vault_audit" "admin" {
  type = "file"

  options = {
    file_path = "/var/log/vault/audit.log"
  }
}
EOF

cat << EOF > auth_methods.tf
resource "vault_auth_backend" "userpass" {
  type = "userpass"
}
resource "vault_auth_backend" "approle" {
  type = "approle"
}
resource "vault_auth_backend" "cert" {
    path = "cert"
    type = "cert"
}
EOF

cat << EOF > pki_root_ca.tf
resource "vault_mount" "root_v1" {
  path        = "dmann-xyz/v1/root/v1"
  type        = "pki"
  description = "dmann.xyz Root PKI Mount"
}

resource "vault_pki_secret_backend_root_cert" "root_v1" {
  depends_on            = [vault_mount.root_v1]
  backend               = vault_mount.root_v1.path
  type                  = "internal"
  common_name           = "DmannXYZ Certification Authority - Root"
  ttl                   = "315360000"
  format                = "pem"
  private_key_format    = "der"
  key_type              = "rsa"
  key_bits              = 4096
  exclude_cn_from_sans  = true
  ou                   = "DmannXYZ Certification Authority"
  organization         = "DmannXYZ"
  country              = "AU"
  locality             = "NSW"
  province             = "Sydney"
}

EOF


cat << EOF > pki_int_ca1.tf
resource "vault_mount" "dmann_xyz_v1_ica1_v1" {
 path                      = "dmann-xyz/v1/ica1/v1"
 type                      = "pki"
 description               = "PKI engine hosting intermediate CA1 v1 for test org"
 default_lease_ttl_seconds = local.default_1hr_in_sec
 max_lease_ttl_seconds     = local.default_1y_in_sec
}

resource "vault_pki_secret_backend_intermediate_cert_request" "dmann_xyz_v1_ica1_v1" {
 depends_on   = [vault_mount.dmann_xyz_v1_ica1_v1]
 backend      = vault_mount.dmann_xyz_v1_ica1_v1.path
 type         = "internal"
 common_name  = "DmannXYZ Certification Authority - CA1 v1"
 key_type     = "rsa"
 key_bits     = "2048"
 ou                   = "DmannXYZ Certification Authority"
 organization         = "DmannXYZ"
 country              = "AU"
 locality             = "NSW"
 province             = "Sydney"
}

resource "vault_pki_secret_backend_root_sign_intermediate" "dmann_xyz_v1_sign_ica1_v1_by_ica1_v1" {
 depends_on = [
   vault_mount.root_v1,
   vault_pki_secret_backend_root_cert.root_v1,
   vault_pki_secret_backend_intermediate_cert_request.dmann_xyz_v1_ica1_v1,
 ]
 backend              = vault_mount.root_v1.path
 csr                  = vault_pki_secret_backend_intermediate_cert_request.dmann_xyz_v1_ica1_v1.csr
 common_name          = "DmannXYZ Certification Authority - v1.1"
 exclude_cn_from_sans = true
 ou                   = "DmannXYZ Certification Authority"
 organization         = "DmannXYZ"
 country              = "AU"
 locality             = "NSW"
 province             = "Sydney"
 max_path_length      = 1
 ttl                  = local.default_1y_in_sec
}

resource "vault_pki_secret_backend_intermediate_set_signed" "dmann_xyz_v1_ica1_v1_signed_cert" {
 depends_on  = [vault_pki_secret_backend_root_sign_intermediate.dmann_xyz_v1_sign_ica1_v1_by_ica1_v1]
 backend     = vault_mount.dmann_xyz_v1_ica1_v1.path
 certificate = vault_pki_secret_backend_root_sign_intermediate.dmann_xyz_v1_sign_ica1_v1_by_ica1_v1.certificate
}
EOF

cat << EOF > pki_int_ca2.tf
resource "vault_mount" "dmann_xyz_v1_ica2_v1" {
 path                      = "dmann-xyz/v1/ica2/v1"
 type                      = "pki"
 description               = "PKI engine hosting intermediate CA2 v1 for test org"
 default_lease_ttl_seconds = local.default_1hr_in_sec
 max_lease_ttl_seconds     = local.default_1y_in_sec
}

resource "vault_pki_secret_backend_intermediate_cert_request" "dmann_xyz_v1_ica2_v1" {
 depends_on   = [vault_mount.dmann_xyz_v1_ica2_v1]
 backend      = vault_mount.dmann_xyz_v1_ica2_v1.path
 type         = "internal"
 common_name  = "DmannXYZ Certification Authority - CA2 v1"
 key_type     = "rsa"
 key_bits     = "2048"
 ou                   = "DmannXYZ Certification Authority"
 organization         = "DmannXYZ"
 country              = "AU"
 locality             = "NSW"
 province             = "Sydney"
}

resource "vault_pki_secret_backend_root_sign_intermediate" "dmann_xyz_v1_sign_ica2_v1_by_ica1_v1" {
 depends_on = [
   vault_pki_secret_backend_intermediate_set_signed.dmann_xyz_v1_ica1_v1_signed_cert,
   vault_pki_secret_backend_intermediate_cert_request.dmann_xyz_v1_ica2_v1,
 ]
 backend              = vault_mount.dmann_xyz_v1_ica1_v1.path
 csr                  = vault_pki_secret_backend_intermediate_cert_request.dmann_xyz_v1_ica2_v1.csr
 common_name          = "Intermediate CA2 v1.1"
 exclude_cn_from_sans = true
 ou                   = "DmannXYZ Certification Authority"
 organization         = "DmannXYZ"
 country              = "AU"
 locality             = "NSW"
 province             = "Sydney"
 max_path_length      = 1
 ttl                  = local.default_1y_in_sec
}

resource "vault_pki_secret_backend_intermediate_set_signed" "dmann_xyz_v1_ica2_v1_signed_cert" {
 depends_on  = [vault_pki_secret_backend_root_sign_intermediate.dmann_xyz_v1_sign_ica2_v1_by_ica1_v1]
 backend     = vault_mount.dmann_xyz_v1_ica2_v1.path
 certificate = vault_pki_secret_backend_root_sign_intermediate.dmann_xyz_v1_sign_ica2_v1_by_ica1_v1.certificate
}
EOF

cat << EOF > pki_int_ca2_roles.tf
resource "vault_pki_secret_backend_role" "role-pki-ca2-dmann-xyz" {
 backend            = vault_mount.dmann_xyz_v1_ica2_v1.path
 name               = "dmann-dot-xyz-subdomain"
 ttl                = local.default_1hr_in_sec
 allow_ip_sans      = true
 key_type           = "rsa"
 key_bits           = 2048
 key_usage          = [ "DigitalSignature"]
 allow_any_name     = false
 allow_localhost    = true
 allowed_domains    = ["dmann.xyz"]
 allow_bare_domains = false
 allow_subdomains   = true
 server_flag        = true
 client_flag        = true
 no_store           = false
}

resource "vault_pki_secret_backend_role" "role-pki-ca2-node" {
 backend            = vault_mount.dmann_xyz_v1_ica2_v1.path
 name               = "dmann-dot-xyz-node"
 ttl                = local.default_1hr_in_sec
 allow_ip_sans      = true
 key_type           = "rsa"
 key_bits           = 2048
 key_usage          = [ "DigitalSignature"]
 allow_any_name     = false
 allow_localhost    = false
 allowed_domains    = ["homelab.dmann.xyz"]
 allow_bare_domains = false
 allow_subdomains   = true
 server_flag        = true
 client_flag        = true
 no_store           = false
}
EOF

cat << EOF > identity_root.tf
resource "vault_policy" "root" {
  name = "admin"

  policy = <<EOT
# Read system health check
path "sys/health"
{
  capabilities = ["read", "sudo"]
}

# Create and manage ACL policies broadly across Vault

# List existing policies
path "sys/policies/acl"
{
  capabilities = ["list"]
}

# Create and manage ACL policies
path "sys/policies/acl/*"
{
  capabilities = ["create", "read", "update", "delete", "list", "sudo"]
}

# Enable and manage authentication methods broadly across Vault

# Manage auth methods broadly across Vault
path "auth/*"
{
  capabilities = ["create", "read", "update", "delete", "list", "sudo"]
}

# Create, update, and delete auth methods
path "sys/auth/*"
{
  capabilities = ["create", "update", "delete", "sudo"]
}

# Identity
path "identity/*"
{
  capabilities = ["create", "read", "update", "delete", "list", "sudo"]
}

# List auth methods
path "sys/auth"
{
  capabilities = ["read"]
}

# Enable and manage the key/value secrets engine at `secret/` path

# List, create, update, and delete key/value secrets
path "secret/*"
{
  capabilities = ["create", "read", "update", "delete", "list", "sudo"]
}

# Manage secrets engines
path "sys/mounts/*"
{
  capabilities = ["create", "read", "update", "delete", "list", "sudo"]
}

# List existing secrets engines.
path "sys/mounts"
{
  capabilities = ["read"]
}
EOT
}

resource "vault_identity_group" "root" {
  name     = "root"
  type     = "internal"
  policies = [
    vault_policy.root.name
  ]
  member_entity_ids = [
    vault_identity_entity.admin.id
  ]
}
resource "vault_identity_entity" "admin" {
  name      = "admin"
  policies  = []
}
EOF


cat << EOF > oidc.tf
resource "vault_identity_oidc" "server" {
  issuer = "https://vault.homelab.dmann.xyz"
}

resource "vault_identity_oidc_scope" "groups" {
  name        = "groups"
  template    = <<EOT
{
  "groups": {{identity.entity.groups.names}} 
}
EOT
  description = "Vault OIDC Groups Scope"
}
resource "vault_identity_oidc_scope" "user" {
  name        = "user"
  template    = <<EOT
{
    "username": {{identity.entity.name}},
    "contact": {
        "email": {{identity.entity.metadata.email}},
        "phone_number": {{identity.entity.metadata.phone_number}}
    }
}
EOT
  description = "Vault OIDC user Scope"
}
resource "vault_identity_oidc_provider" "vault" {
  name = "default"
  https_enabled = true
  allowed_client_ids = [ "*" ]
  scopes_supported = [
    vault_identity_oidc_scope.user.name,
    vault_identity_oidc_scope.groups.name
  ]
}

resource "vault_identity_oidc_key" "key" {
  name      = "key"
  algorithm = "RS256"
}

resource "vault_identity_oidc_role" "role" {
  name = "role"
  key  = vault_identity_oidc_key.key.name
}

resource "vault_identity_oidc_key_allowed_client_id" "role" {
  key_name          = vault_identity_oidc_key.key.name
  allowed_client_id = vault_identity_oidc_role.role.client_id
}

resource "vault_identity_oidc_assignment" "root" {
  name       = "assignment"
  entity_ids = [
    vault_identity_entity.admin.id,
  ]
  group_ids  = [
    vault_identity_group.root.id,
  ]
}
EOF

cat << EOF > identity_admin.tf
resource "vault_generic_endpoint" "generic-user-admin" {
  depends_on           = [
    vault_auth_backend.userpass
  ]
  path                 = "auth/userpass/users/admin"
  ignore_absent_fields = true

  data_json = <<EOT
{
  "policies": [],
  "password": "changeme"
}
EOT
}

resource "vault_identity_entity_alias" "root-codingninja-userpass" {
  name            = "admin"
  mount_accessor  = vault_auth_backend.userpass.accessor
  canonical_id    = vault_identity_entity.admin.id
}
EOF

cat << 'EOF' > node.tf
resource "vault_policy" "node" {
  name = "node"

  policy = <<EOT
path "secret/data/node/{{identity.entity.name}}/*" {
    capabilities = [ "create", "update", "read", "delete", "list" ]
}
path "secret/data/node/{{identity.entity.name}}" {
    capabilities = [ "create", "update", "read", "delete", "list" ]
} 
EOT
}

resource "vault_identity_group" "node" {
  name     = "node"
  type     = "internal"
  policies = [
    vault_policy.node.name, 
    vault_policy.node-provisioner.name
  ]
  external_member_entity_ids = true
}

resource "vault_identity_entity" "node" {
  for_each = local.nodes

  name      = "node-${each.key}"
  policies  = []
}

resource "vault_identity_group_member_entity_ids" "nodes" {
  member_entity_ids = toset([for v in vault_identity_entity.node : v.id])


  exclusive = false

  group_id = vault_identity_group.node.id
}

resource "vault_identity_entity_alias" "node-cert" {
  for_each = vault_identity_entity.node
  name            = "node-${each.key}"
  mount_accessor  = vault_auth_backend.cert.accessor
  canonical_id    = each.value.id
}


resource "vault_policy" "node-provisioner" {
  name = "node-provisioner"

  policy = <<EOT
path "${vault_pki_secret_backend_role.role-pki-ca2-node.backend}/issue/${vault_pki_secret_backend_role.role-pki-ca2-node.name}" {
    capabilities = [ "update" ]
}

EOT
}

resource "vault_approle_auth_backend_role" "node-provisioner" {
  backend        = vault_auth_backend.approle.path
  role_name      = "node-provisioner"
  role_id = "node-provisioner"
  token_policies = [
    vault_policy.node-provisioner.name
  ]
  secret_id_num_uses = 1
  secret_id_ttl = 300
}

resource "vault_cert_auth_backend_role" "node" {
    name           = "node"
    certificate    = vault_pki_secret_backend_root_sign_intermediate.dmann_xyz_v1_sign_ica2_v1_by_ica1_v1.certificate
    backend        = vault_auth_backend.cert.path
    token_ttl      = 300
    token_max_ttl  = 600
    token_policies = []
}
resource "vault_approle_auth_backend_role_secret_id" "node" {
  for_each = local.nodes
  backend   = vault_auth_backend.approle.path
  role_name = vault_approle_auth_backend_role.node-provisioner.role_name
  cidr_list = [for ip in each.value.ips : "${ip}/32" ]
  wrapping_ttl = 300

  metadata = jsonencode(
    {
      "name" = each.key
    }
  )
}
resource "vault_identity_entity_alias" "node-cert" {
  for_each = vault_identity_entity.node
  name            = "node-${each.key}"
  mount_accessor  = vault_auth_backend.cert.accessor
  canonical_id    = each.value.id
}

output "node-provision-secret-id" {
  sensitive = true
  value = { for key, node in vault_approle_auth_backend_role_secret_id.node: key => {
    accessor: node.accessor,
    wrapping_accessor: node.wrapping_accessor,
    wrapping_token: node.wrapping_token,
  }}
}
EOF

# terraform init
VAULT_TOKEN=$(jq -r '.root_token' < /opt/vault/init.json) terraform apply