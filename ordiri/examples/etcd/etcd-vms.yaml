apiVersion: compute.ordiri.com/v1alpha1
kind: VirtualMachineDeployment
metadata:
  name: etcd
spec:
  replicas: 3
  template:
    metadata:
      creationTimestamp: null
    spec:
      userData: |
        #!/bin/bash
        set -eou pipefail

        cd $(mktemp -d)
        apt update && apt install -y gpg jq wget curl ca-certificates

        # We do this in 2 stages because the first curl imports the root which issues the second
        curl -k -s -L -XGET https://vault-root-0.ordiri:8200/v1/pki_int/ca_chain | awk 'BEGIN {c=0;} /BEGIN CERT/{c++} { print > "/usr/local/share/ca-certificates/vault-root." c ".pem"}'
        update-ca-certificates

        curl -s -L -XGET https://vault-2.ordiri:8200/v1/pki/ca_chain  | awk 'BEGIN {c=0;} /BEGIN CERT/{c++} { print > "/usr/local/share/ca-certificates/vault." c ".pem"}'
        update-ca-certificates
        
        local_ip=$(curl 169.254.169.254/latest/meta-data/local-ipv4)

        wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg >/dev/null
        if [[ -z "$(gpg --no-default-keyring --keyring /usr/share/keyrings/hashicorp-archive-keyring.gpg --fingerprint | grep "E8A0 32E0 94D8 EB4E A189  D270 DA41 8C88 A321 9F7B")" ]]; then
          echo "gpp fingerprint was not valid"
          exit 2
        fi
       
        echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com bullseye main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
        sudo apt update && sudo apt install vault
        
        tee /usr/bin/vault-cert <<'EOF'
        #!/usr/bin/env bash

        tmp=$(mktemp)

        export local_hostname=$(curl 169.254.169.254/latest/meta-data/local-hostname)
        export local_ip=$(curl 169.254.169.254/latest/meta-data/local-ipv4)

        VAULT_TOKEN=$(vault write auth/approle/login role_id=$VAULT_ROLE_ID -format=json | jq -r '.auth.client_token') \
          vault write --format=json $VAULT_PATH \
            common_name="${local_hostname}.homelab.dmann.xyz" \
            ip_sans="${local_ip}" \
            alt_names="${local_hostname}.ordiri" \
            ttl="24h" > $tmp


        cat $tmp | jq -r '.data.ca_chain | join("\n")' > $CA_LOCATION
        cat $tmp | jq -r '.data.certificate' > $CERT_LOCATION
        cat $tmp | jq -r '.data.private_key' > $KEY_LOCATION
        EOF

        chmod +x /usr/bin/vault-cert

        tee /etc/systemd/system/cert-renewer@.service <<'EOF'
        [Unit]
        Description=Certificate renewer for %I
        After=network-online.target
        Documentation=https://github.com/smallstep/cli/blob/005920ad4122fa5838c338b567d6584fcc33c1cc/systemd/cert-renewer@.service
        StartLimitIntervalSec=0

        [Service]
        Type=oneshot
        User=root

        Environment=CA_LOCATION=/etc/ssl/certs/%i-ca.crt
        Environment=CERT_LOCATION=/etc/ssl/certs/%i.crt
        Environment=KEY_LOCATION=/etc/ssl/private/%i.key
        Environment=VAULT_SKIP_VERIFY=true
        Environment=VAULT_ROLE_ID=etcd-node
        Environment=VAULT_ADDR=https://vault-0.ordiri:8200
        Environment=VAULT_PATH=pki/issue/homelab-default

        ExecCondition=/usr/bin/env sh -c "! test -f ${CERT_LOCATION} || ! /usr/bin/openssl x509 -checkend 1500 -noout -in ${CERT_LOCATION}"

        ; ExecStart renews the certificate, if ExecStartPre was successful.
        ExecStart=/usr/bin/vault-cert

        ; Try to reload or restart the systemd service that relies on this cert-renewer
        ; If the relying service doesn't exist, forge ahead.
        ; (In systemd <229, use `reload-or-try-restart` instead of `try-reload-or-restart`)
        ExecStartPost=/usr/bin/env sh -c "! systemctl --quiet is-enabled %i.service || systemctl try-reload-or-restart %i"
        [Install]
        WantedBy=multi-user.target
        EOF

        tee /etc/systemd/system/cert-renewer@.timer <<'EOF'
        [Unit]
        Description=Timer for certificate renewal of %I
        Documentation=https://smallstep.com/docs/step-ca/certificate-authority-server-production
        Documentation=https://github.com/smallstep/cli/blob/005920ad4122fa5838c338b567d6584fcc33c1cc/systemd/cert-renewer%40.timer

        [Timer]
        Persistent=true

        ; Run the timer unit every 15 minutes.
        OnCalendar=*:1/15

        ; Always run the timer on time.
        AccuracySec=1us

        ; Add jitter to prevent a "thundering hurd" of simultaneous certificate renewals.
        RandomizedDelaySec=5m

        [Install]
        WantedBy=timers.target
        EOF

        systemctl daemon-reload
        systemctl enable --now cert-renewer@etcd.timer
        systemctl enable --now cert-renewer@etcd.service
        sleep 5

        local_ip=$(curl 169.254.169.254/latest/meta-data/local-ipv4)
        local_hostname=$(curl 169.254.169.254/latest/meta-data/local-hostname)
        export local_ip local_hostname # Export these so we can use them in envsubst call below

        CLUSTER_PORT=2380
        CLIENT_PORT=2379
        ETCD_VER=v3.5.4
        DOWNLOAD_URL=https://storage.googleapis.com/etcd

        export PATH=$PATH:/usr/local/bin

        cd $(mktemp -d)
        apt-get update -y

        curl -L ${DOWNLOAD_URL}/${ETCD_VER}/etcd-${ETCD_VER}-linux-amd64.tar.gz -o etcd-${ETCD_VER}-linux-amd64.tar.gz
        tar xzvf etcd-${ETCD_VER}-linux-amd64.tar.gz --strip-components=1
        rm -f etcd-${ETCD_VER}-linux-amd64.tar.gz

        ./etcd --version
        ./etcdctl version
        mv ./{etcd,etcdctl} /usr/local/bin/.

        # todo once dns is implemented properly, change this to use the subnet local dns records
        peers=""
        endpoints=""
        for i in $(seq 0 2); do 
          hn="etcd-${i}.ordiri"
          if [[ -n "${peers}" ]]; then
            peers="${peers},"
            endpoints="${endpoints},"
          fi
          peers="${peers}${hn}=https://${hn}:${CLUSTER_PORT}"
          endpoints="${endpoints}https://${hn}:${CLIENT_PORT}"
        done

        local_ip=$(curl 169.254.169.254/latest/meta-data/local-ipv4)
        local_hostname=$(curl 169.254.169.254/latest/meta-data/local-hostname)
        CLUSTER_PORT=2380
        CLIENT_PORT=2379
        export local_ip local_hostname # Export these so we can use them in envsubst call below
        cat << EOF > /etc/systemd/system/etcd.service
        [Unit]
        Description=etcd key-value store
        Documentation=https://github.com/etcd-io/etcd
        After=network-online.target local-fs.target remote-fs.target time-sync.target
        Wants=network-online.target local-fs.target remote-fs.target time-sync.target

        [Service]
        Type=notify
        Environment=ETCD_DATA_DIR=/var/lib/etcd
        Environment=ETCD_NAME=${local_hostname}
        Environment=ETCD_INITIAL_ADVERTISE_PEER_URLS=https://${local_ip}:${CLUSTER_PORT}
        Environment=ETCD_LISTEN_PEER_URLS=https://${local_ip}:${CLUSTER_PORT}
        Environment=ETCD_LISTEN_CLIENT_URLS=https://${local_ip}:${CLIENT_PORT},https://127.0.0.1:${CLIENT_PORT}
        Environment=ETCD_ADVERTISE_CLIENT_URLS=https://${local_ip}:${CLIENT_PORT}
        Environment=ETCD_INITIAL_CLUSTER_TOKEN=etcd-cluster-1
        Environment=ETCD_INITIAL_CLUSTER=${peers}
        Environment=ETCD_INITIAL_CLUSTER_STATE=new
        Environment=ETCD_TRUSTED_CA_FILE=/etc/ssl/certs/etcd-ca.crt
        Environment=ETCD_PEER_CLIENT_CERT_AUTH=true
        Environment=ETCD_CLIENT_CERT_AUTH=true
        Environment=ETCD_PEER_CERT_FILE=/etc/ssl/certs/etcd.crt
        Environment=ETCD_PEER_KEY_FILE=/etc/ssl/private/etcd.key
        Environment=ETCD_CERT_FILE=/etc/ssl/certs/etcd.crt
        Environment=ETCD_KEY_FILE=/etc/ssl/private/etcd.key

        ExecStart=/usr/local/bin/etcd
        Restart=always
        RestartSec=10s
        LimitNOFILE=40000

        [Install]
        WantedBy=multi-user.target
        EOF

        systemctl enable /etc/systemd/system/etcd.service
        systemctl daemon-reload
        systemctl restart etcd

        echo "export ETCDCTL_API=3
        export ETCDCTL_ENDPOINTS=$endpoints
        export ETCDCTL_INSECURE_TRANSPORT=false
        export ETCDCTL_CACERT=/etc/ssl/certs/etcd-ca.crt
        export ETCDCTL_CERT=/etc/ssl/certs/etcd.crt
        export ETCDCTL_KEY=/etc/ssl/private/etcd.key # todo: change this and ship tls certs via metadata server
        " > $HOME/.etcdctl

        echo "
        # Etcd installed
        #
        # To test, please run
        source $HOME/.etcdctl
        etcdctl member list
        "
      bootDevices:
      - hd
      - network
      networkInterfaces:
      - mac: ""
        network: kubevms
        subnet: kubevms-etcd
      node: ""
      role: default
      state: Running
      volumes:
      - device: vda
        hostLocal:
          poolName: etcd
          size: 30Gi
          volName: root
        name: root