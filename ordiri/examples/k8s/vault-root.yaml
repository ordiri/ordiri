# This vault-root is pretty insecure, it should be setup somewhere external
apiVersion: storage.ordiri.com/v1alpha1
kind: Volume
metadata:
  name: vault-root
spec:
  size: 10Gi
  storageClassName: default
  ClaimRef:
    kind: VolumeClaim
    apiVersion: storage.ordiri.com/v1alpha1
    name: vault-root

---
apiVersion: storage.ordiri.com/v1alpha1
kind: VolumeClaim
metadata:
  name: vault-root
spec:
  size: 10Gi
  storageClassName: default
  volumeName: vault-root
---
apiVersion: compute.ordiri.com/v1alpha1
kind: VirtualMachineDeployment
metadata:
  name: vault-root
spec:
  replicas: 1
  template:
    metadata:
      creationTimestamp: null
    spec:
      userData: |
        #!/usr/bin/env bash

        set -eou pipefail

        cd $(mktemp -d)
        apt update && apt install -y gpg jq wget curl
        
        local_ip=$(curl 169.254.169.254/latest/meta-data/local-ipv4)

        wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | tee /usr/share/keyrings/hashicorp-archive-keyring.gpg >/dev/null
        if [[ -z "$(gpg --no-default-keyring --keyring /usr/share/keyrings/hashicorp-archive-keyring.gpg --fingerprint | grep "E8A0 32E0 94D8 EB4E A189  D270 DA41 8C88 A321 9F7B")" ]]; then
          echo "gpp fingerprint was not valid"
          exit 2
        fi
       
        echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com bullseye main" | tee /etc/apt/sources.list.d/hashicorp.list
        apt update && apt install vault
        if [[ -z "$(lsblk /dev/vdb --json | jq -r '.blockdevices[].children // ""')" ]]; then
            # type=83 is equal to 1 root partition that takes the whole disk
            echo 'type=83' | sfdisk  /dev/vdb
            mkfs -t ext4 /dev/vdb1
        fi
        mkdir -p /vault/root 
        eval $(blkid /dev/vdb1 --output export)
        echo "[Unit]
        Description=Vault root mount
        After=network.target

        [Mount]
        What=/dev/disk/by-uuid/$UUID
        Where=/vault/root
        Type=ext4
        Options=defaults

        [Install]
        WantedBy=multi-user.target" > /etc/systemd/system/vault-root.mount

        systemctl enable --now vault-root.mount

        mkdir -p /vault/root/vault-tls

        if [[ ! -f /vault/root/vault-tls/vault.key ]]; then

          echo "[req]
        distinguished_name = req_distinguished_name
        req_extensions = req_ext
        x509_extensions = v3_req
        prompt = no

        [req_distinguished_name]
        C = AU
        ST = NSW
        L = Sydney
        O = Ordiri
        OU = Cloud
        CN = vault.homelab.dmann.xyz

        [v3_req]
        keyUsage = keyEncipherment, dataEncipherment
        extendedKeyUsage = serverAuth
        subjectAltName = @alt_names
        [req_ext]
        subjectAltName = @alt_names

        [alt_names]
        DNS.1 = ${local_hostname}.homelab.dmann.xyz
        DNS.2 = ${local_hostname}.ordiri
        IP.1 = ${local_ip}" > /vault/root/vault-tls/vault.conf
          openssl req -x509 -nodes -days 730 -newkey rsa:4096 -keyout /vault/root/vault-tls/vault.key -out /vault/root/vault-tls/vault.crt -config /vault/root/vault-tls/vault.conf
        fi

        echo 'disable_mlock = true
        
        ui = true

        storage "file" {
          path = "/vault/root/vault-data"
        }

        # HTTPS listener
        listener "tcp" {
          address       = "0.0.0.0:8200"
          tls_cert_file = "/vault/root/vault-tls/vault.crt"
          tls_key_file  = "/vault/root/vault-tls/vault.key"
        }' > /etc/vault.d/vault.hcl

        chown -Rf vault:vault /vault/root 

        systemctl daemon-reload
        systemctl restart vault

        export VAULT_SKIP_VERIFY=true
        if [[ "$(vault status --format=json | jq -r '.initialized')" == "false" ]]; then
          vault operator init --format=json | tee /vault/root/vault-operator-init.log
        fi

        if [[ "$(vault status --format=json | jq -r '.sealed')" == "true" ]]; then
          # Minus 1 to make the looping easier
          threshold=$(cat /vault/root/vault-operator-init.log | jq -r '.unseal_threshold - 1')
          for idx in $(seq 0 $threshold); do
            vault operator unseal $(cat /vault/root/vault-operator-init.log | jq --arg idx "$idx" -r '.unseal_keys_hex[$idx | tonumber]')
          done
        fi
        
        cat /vault/root/vault-operator-init.log | jq -r '.root_token' | vault login  -
        if ! vault audit list -format json | jq -e '.["file/"]'; then
          vault audit enable file file_path=/vault/root/audit.log
        fi

        # Setup the transit engine we'll use to seal/unseal the cluster
        if ! vault secrets list -format json | jq -e '.["transit/"]'; then
          vault secrets enable transit
          vault write -f transit/keys/vault-vms-autounseal
        fi

        tee autounseal.hcl <<EOF
        path "transit/encrypt/vault-vms-autounseal" {
          capabilities = [ "update" ]
        }

        path "transit/decrypt/vault-vms-autounseal" {
          capabilities = [ "update" ]
        }
        EOF

        tee sign-root-ca.hcl <<EOF
        path "pki_int/root/sign-intermediate" {
          capabilities = [ "update" ]
        }
        EOF

        tee generate-cert.hcl <<EOF
          path "pki_int/issue/dmann-default" {
            capabilities = [ "update" ]
          }
        EOF

        vault policy write generate-cert generate-cert.hcl
        vault policy write sign-root-ca sign-root-ca.hcl
        vault policy write vault-vms-autounseal autounseal.hcl

        # Setup the transit engine we'll use to seal/unseal the cluster
        if ! vault auth list -format json | jq -e '.["approle/"]'; then
          vault auth enable approle
        fi

        # Todo: should be dynamic and this whole thing is pretty silly buti it's quasi
        # secure
        vault_ips="10.200.3.0/24"
        vault write auth/approle/role/vault-vms-autounseal token_policies="vault-vms-autounseal" \
          token_ttl=5m token_max_ttl=10m bind_secret_id=false token_bound_cidrs=${vault_ips},127.0.0.1/32
        # make it possible to login with a simple id
        vault write auth/approle/role/vault-vms-autounseal/role-id role_id=vault-vms-autounseal 

        vault write auth/approle/role/vault-ca-bootstrap token_policies="sign-root-ca,generate-cert" \
          token_ttl=5m token_max_ttl=10m bind_secret_id=false token_bound_cidrs=${vault_ips},127.0.0.1/32
        # make it possible to login with a simple id
        vault write auth/approle/role/vault-ca-bootstrap/role-id role_id=vault-ca-bootstrap 

        # Setup the transit engine we'll use to seal/unseal the cluster
        if ! vault secrets list -format json | jq -e '.["pki/"]'; then
          vault secrets enable pki
          vault secrets tune -max-lease-ttl=87600h pki
          vault write -field=certificate pki/root/generate/internal \
              common_name="dmann.xyz Root CA" \
              issuer_name="dmann-xyz-2022" \
              ttl=87600h > root_2022_ca.crt

          vault write pki/config/urls \
            issuing_certificates="https://${local_hostname}.ordiri:8200/v1/pki/ca" \
            crl_distribution_points="https://${local_hostname}.ordiri:8200/v1/pki/crl"
        fi
        vault write pki/roles/dmann-xyz-2022 allow_any_name=true

        if ! vault secrets list -format json | jq -e '.["pki_int/"]'; then
          vault secrets enable -path=pki_int pki
          vault secrets tune -max-lease-ttl=43800h pki_int
          vault write -format=json pki_int/intermediate/generate/internal \
            common_name="dmann.xyz Intermediate Authority" \
            issuer_name="dmann-default" \
            | jq -r '.data.csr' > pki_intermediate.csr

          vault write -format=json pki/root/sign-intermediate \
            issuer_ref="dmann-xyz-2022" \
            csr=@pki_intermediate.csr \
            format=pem_bundle ttl="43800h" \
            | jq -r '.data.certificate' > intermediate.cert.pem

          vault write pki_int/intermediate/set-signed certificate=@intermediate.cert.pem
        fi
        vault write pki_int/roles/dmann-default \
          issuer_ref="$(vault read -field=default pki_int/config/issuers)" \
          allowed_domains="dmann.xyz,ordiri" \
          allow_subdomains=true \
          max_ttl="720h"
      bootDevices:
      - hd
      - network
      networkInterfaces:
      - network: kubevms
        subnet: kubevms-vault
      role: default
      state: Running
      volumes:
      - device: vda
        hostLocal:
          poolName: vault
          size: 5Gi
          volName: root
        name: root
      - device: vdb
        volumeClaim:
          claimName: vault-root
        name: vault-root